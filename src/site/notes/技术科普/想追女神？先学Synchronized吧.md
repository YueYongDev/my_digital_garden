---
{"dg-publish":true,"permalink":"//synchronized/"}
---

在之前的[[技术科普/从找对象到多线程\|从找对象到多线程]]一文中我曾介绍了一些和多线程有关的知识，而谈到多线程，就一定离不开「锁」这个名词。在 Java 中，锁的使用主要有两种：Synchronized 关键字和 Lock 接口，本文将会换个角度来聊一聊 synchronized 中的锁。

Synchronized 用的锁是存在**对象头**里的，用来表明当前对象所持有的锁。在 Java SE1.6 之前，Synchronized 是作为重量锁出现的，一旦使用了 synchronized，就一定会阻塞到其他线程。而在 Java SE1.6 后，为了减少获得锁和释放锁带来的**性能**问题，引入了"偏向锁"和"轻量锁"的概念。由此可以得知，在新的 Java 中，锁一共有 4 种状态：**无锁状态、偏向锁状态、轻量锁状态和重量锁状态**。这几个状态会随着竞争不断升级且**只能升级不能降级**，即轻量锁只会升级到重量锁而不会降级到偏向锁。

以上的解释未免太过官方了，我们从一个小例子入手。

![](https://cdn.ytools.xyz/uPic/007S8ZIlgy1gitqf3b5s9j30p00bo3zi.jpg)

我们用女神来表示同步代码块，就好比女神有很多追求者，同步代码块也会被很多线程执行。有一天女神的微博状态变成了「单身」，此时她就处于**无锁**状态，于是这些追求者纷纷创建了一个名为 **「找对象」的线程** ，此时对于女神（对象）来说，还没有任何线程来访问她，所以当第一个男生小 A 试图邀请她看电影的时候 **（获取锁）**，她会偏向小 A 的邀请，此时她就是处于 **「偏向锁」** 状态的。有了这次经历之后，小 A 就知道该怎么邀请女神而不用反复试探了，这就是 **「可重入锁」** ，即同一个线程可以**多次**访问同一代码块。

再后来女神发了一条微博，说今天和这个男生看电影很开心。这条微博被其他男生看见了，大家也都知道了女神这个对象的偏向状态了。可还是有男生小 B 想追女神，此时这两个男生各自「找对象」的线程就在女神这个对象上产生了**竞争**。

![](https://cdn.ytools.xyz/uPic/007S8ZIlgy1gitqfbnj2yj307w05wt8o.jpg)

小 B 一直关注女神的微博动态，他心想着，只要小 A 被女神拒绝了，女神就会变成「无锁」状态，自己也就有机会被女神偏向了。女神也知道小 B 在追自己，为了找到最合适的另一半，女神也在暗中观察小 B，有**两个竞争者**同时竞争，这时候她就处于 **「轻量锁」**的状态。虽然女神明显更喜欢小 A，但在小 B 心里觉得小 A 除了比自己早点出现外根本不具有和自己竞争的能力，于是不断给女神献殷勤，保持关系，这就叫**自旋**，不断的将自己的时间花费在获取锁上，逐渐成为一条舔 🐶。

![](https://cdn.ytools.xyz/uPic/007S8ZIlgy1gitqfexhohj30k00k0mxx.jpg)

虽然一开始女神也会偶尔答应小 B 的邀请，但当竞争者越来越多后，小 B 变得疯狂起来，追求逐渐变成了骚扰，女神也逐渐不耐烦起来。最终在小 A 的努力下，女神和小 A 确定了关系，并发了微博告知众人，此时她的状态就升级成为 **「重量锁」** 状态。这时，除了小 A，其他所有竞争者的「找对象」线程都没有办法再追求女神了。这样做的好处就是赶紧断了那些追求者的念头，让他们可以早日觅得其他良人，**不要在一棵树上吊死**。

从线程的角度来看，重量锁使除了拥有锁的线程外的其他所有线程都阻塞，这样可以有效**防止 CPU 空转**，避免造成资源的浪费。

在偏向锁和轻量锁阶段，女神还没有和任何人确定关系，只要给点甜头小 B 等其他追求者都会很开心，这是一种「乐观锁」。而一旦女神和小 A 确定了关系，自身状态升级为重量锁后，小 B 就很不开心了，对他来说这就是一种「悲观锁」。

![](https://cdn.ytools.xyz/uPic/007S8ZIlgy1gitqficbb9j3069069jrb.jpg)

当然，上面所说的乐观锁和悲观锁只是为了方便大家的记忆，实际的定义并不是这样。

所谓悲观锁（Pessimistic Lock），顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改。所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会 block 直到它拿到锁。悲观锁假定会发生并发冲突，因此屏蔽一切可能违反数据完整性的操作。就跟上面的例子中，女神已有男朋友之后就不会再答应其他男生的邀约类似。

而乐观锁（Optimistic Lock），顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。

![](https://cdn.ytools.xyz/uPic/007S8ZIlgy1gitqfllvhnj307307374c.jpg)

想到这，我不禁开始怀疑 Synchronized 的设计者是不是经历过类似的事情，不然为什么会这么熟练。只是不知道他究竟是那个线程还是被锁起来的对象。

以上就是本文的全部内容了，如果你觉得本文对你有所帮助，不妨点个关注支持一波，也欢迎大家在下方评论区留言 。
